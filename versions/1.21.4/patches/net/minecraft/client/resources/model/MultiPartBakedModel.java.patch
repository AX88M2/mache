--- a/net/minecraft/client/resources/model/MultiPartBakedModel.java
+++ b/net/minecraft/client/resources/model/MultiPartBakedModel.java
@@ -7,16 +_,22 @@
 import java.util.List;
 import java.util.Map;
 import java.util.function.Predicate;
+import java.util.function.Supplier;
 import javax.annotation.Nullable;
+
+import net.fabricmc.fabric.api.renderer.v1.mesh.QuadEmitter;
 import net.minecraft.client.renderer.block.model.BakedQuad;
+import net.minecraft.core.BlockPos;
 import net.minecraft.core.Direction;
 import net.minecraft.util.RandomSource;
+import net.minecraft.world.level.BlockAndTintGetter;
 import net.minecraft.world.level.block.state.BlockState;
 
-public class MultiPartBakedModel extends DelegateBakedModel {
+public class MultiPartBakedModel extends DelegateBakedModel implements BakedModel{
     private final List<MultiPartBakedModel.Selector> selectors;
     private final Map<BlockState, BitSet> selectorCache = new Reference2ObjectOpenHashMap<>();
-
+    private boolean isVanilla = true;
+    
     private static BakedModel getFirstModel(List<MultiPartBakedModel.Selector> selectors) {
         if (selectors.isEmpty()) {
             throw new IllegalArgumentException("Model must have at least one selector");
@@ -28,6 +_,12 @@
     public MultiPartBakedModel(List<MultiPartBakedModel.Selector> parent) {
         super(getFirstModel(parent));
         this.selectors = parent;
+        for (MultiPartBakedModel.Selector selector : selectors) {
+            if (!selector.model().isVanillaAdapter()) {
+                isVanilla = false;
+                break;
+            }
+        }
     }
 
     @Override
@@ -63,5 +_,48 @@
     }
 
     public record Selector(Predicate<BlockState> condition, BakedModel model) {
+    }
+
+    @Override
+    public boolean isVanillaAdapter() {
+        return isVanilla;
+    }
+
+    @Override
+    public void emitBlockQuads(QuadEmitter emitter, BlockAndTintGetter blockView, BlockState state, BlockPos pos, Supplier<RandomSource> randomSupplier, Predicate<@org.jetbrains.annotations.Nullable Direction> cullTest) {
+        BitSet bitSet = this.selectorCache.get(state);
+
+        if (bitSet == null) {
+            bitSet = new BitSet();
+
+            for (int i = 0; i < this.selectors.size(); i++) {
+                MultiPartBakedModel.Selector selector = selectors.get(i);
+
+                if (selector.condition().test(state)) {
+                    bitSet.set(i);
+                }
+            }
+
+            selectorCache.put(state, bitSet);
+        }
+
+        RandomSource random = randomSupplier.get();
+        // Imitate vanilla passing a new random to the submodels
+        long randomSeed = random.nextLong();
+        Supplier<RandomSource> subModelRandomSupplier = () -> {
+            random.setSeed(randomSeed);
+            return random;
+        };
+
+        for (int i = 0; i < this.selectors.size(); i++) {
+            if (bitSet.get(i)) {
+                selectors.get(i).model().emitBlockQuads(emitter, blockView, state, pos, subModelRandomSupplier, cullTest);
+            }
+        }
+    }
+
+    @Override
+    public void emitItemQuads(QuadEmitter emitter, Supplier<RandomSource> randomSupplier) {
+        // Vanilla doesn't use MultipartBakedModel for items.
     }
 }
