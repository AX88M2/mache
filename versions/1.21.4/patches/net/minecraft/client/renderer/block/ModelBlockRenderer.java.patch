--- a/net/minecraft/client/renderer/block/ModelBlockRenderer.java
+++ b/net/minecraft/client/renderer/block/ModelBlockRenderer.java
@@ -7,6 +_,8 @@
 import java.util.BitSet;
 import java.util.List;
 import javax.annotation.Nullable;
+
+import net.fabricmc.fabric.impl.client.indigo.renderer.render.BlockRenderContext;
 import net.minecraft.CrashReport;
 import net.minecraft.CrashReportCategory;
 import net.minecraft.ReportedException;
@@ -31,38 +_,32 @@
     private final BlockColors blockColors;
     private static final int CACHE_SIZE = 100;
     static final ThreadLocal<ModelBlockRenderer.Cache> CACHE = ThreadLocal.withInitial(ModelBlockRenderer.Cache::new);
-
+    private static final ThreadLocal<BlockRenderContext> CONTEXTS = ThreadLocal.withInitial(BlockRenderContext::new);
     public ModelBlockRenderer(BlockColors blockColors) {
         this.blockColors = blockColors;
     }
 
-    public void tesselateBlock(
-        BlockAndTintGetter level,
-        BakedModel model,
-        BlockState state,
-        BlockPos pos,
-        PoseStack poseStack,
-        VertexConsumer consumer,
-        boolean checkSides,
-        RandomSource random,
-        long seed,
-        int packedOverlay
-    ) {
-        boolean flag = Minecraft.useAmbientOcclusion() && state.getLightEmission() == 0 && model.useAmbientOcclusion();
-        poseStack.translate(state.getOffset(pos));
+    public void tesselateBlock(BlockAndTintGetter level, BakedModel model, BlockState state, BlockPos pos, PoseStack poseStack, VertexConsumer consumer, boolean checkSides, RandomSource random, long seed, int packedOverlay) {
+        //if (!model.isVanillaAdapter()) {
+            CONTEXTS.get().render(level, model, state, pos, poseStack, consumer, checkSides, random, seed, packedOverlay);
+        //}
+        if(false){
+            boolean flag = Minecraft.useAmbientOcclusion() && state.getLightEmission() == 0 && model.useAmbientOcclusion();
+            poseStack.translate(state.getOffset(pos));
 
-        try {
-            if (flag) {
-                this.tesselateWithAO(level, model, state, pos, poseStack, consumer, checkSides, random, seed, packedOverlay);
-            } else {
-                this.tesselateWithoutAO(level, model, state, pos, poseStack, consumer, checkSides, random, seed, packedOverlay);
+            try {
+                if (flag) {
+                    this.tesselateWithAO(level, model, state, pos, poseStack, consumer, checkSides, random, seed, packedOverlay);
+                } else {
+                    this.tesselateWithoutAO(level, model, state, pos, poseStack, consumer, checkSides, random, seed, packedOverlay);
+                }
+            } catch (Throwable var16) {
+                CrashReport crashReport = CrashReport.forThrowable(var16, "Tesselating block model");
+                CrashReportCategory crashReportCategory = crashReport.addCategory("Block model being tesselated");
+                CrashReportCategory.populateBlockDetails(crashReportCategory, level, pos, state);
+                crashReportCategory.setDetail("Using AO", flag);
+                throw new ReportedException(crashReport);
             }
-        } catch (Throwable var16) {
-            CrashReport crashReport = CrashReport.forThrowable(var16, "Tesselating block model");
-            CrashReportCategory crashReportCategory = crashReport.addCategory("Block model being tesselated");
-            CrashReportCategory.populateBlockDetails(crashReportCategory, level, pos, state);
-            crashReportCategory.setDetail("Using AO", flag);
-            throw new ReportedException(crashReport);
         }
     }
 
@@ -215,7 +_,7 @@
         );
     }
 
-    private void calculateShape(
+    public void calculateShape(
         BlockAndTintGetter level, BlockState state, BlockPos pos, int[] vertices, Direction direction, @Nullable float[] shape, BitSet shapeFlags
     ) {
         float f = 32.0F;
@@ -683,9 +_,9 @@
         }
     }
 
-    static class AmbientOcclusionFace {
-        final float[] brightness = new float[4];
-        final int[] lightmap = new int[4];
+    public static class AmbientOcclusionFace {
+        public final float[] brightness = new float[4];
+        public final int[] lightmap = new int[4];
 
         public AmbientOcclusionFace() {
         }
